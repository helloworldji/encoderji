import os
import base64
import zlib
import random
import string
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import telebot
from telebot import types
import tempfile
import ast
import re

# Set your bot token here (get from @BotFather)
BOT_TOKEN = os.getenv('BOT_TOKEN', 'YOUR_BOT_TOKEN_HERE')

bot = telebot.TeleBot(BOT_TOKEN)

class CodeProtector:
    def __init__(self):
        self.salt_length = 32
        self.iterations = 100000
        
    def generate_key(self, password: str, salt: bytes) -> bytes:
        """Generate encryption key from password and salt"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=self.iterations,
        )
        return base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    def obfuscate_strings(self, code: str) -> str:
        """Obfuscate string literals in the code"""
        def replace_string(match):
            quote = match.group(1)
            content = match.group(2)
            if len(content) < 3:  # Skip very short strings
                return match.group(0)
            encoded = base64.b64encode(content.encode()).decode()
            return f'__import__("base64").b64decode("{encoded}").decode()'
        
        # Replace strings but avoid breaking syntax
        code = re.sub(r'(["\'])((?:(?!\1)[^\\]|\\.)*)(\1)', replace_string, code)
        return code
    
    def add_dummy_code(self, code: str) -> str:
        """Add dummy functions and variables"""
        dummy_funcs = []
        for _ in range(random.randint(3, 7)):
            func_name = ''.join(random.choices(string.ascii_letters, k=random.randint(8, 15)))
            dummy_code = f"""
def {func_name}():
    {''.join(random.choices(string.ascii_letters + string.digits, k=50))}
    return {''.join(random.choices(string.digits, k=10))}
"""
            dummy_funcs.append(dummy_code)
        
        dummy_vars = []
        for _ in range(random.randint(5, 10)):
            var_name = ''.join(random.choices(string.ascii_letters, k=random.randint(6, 12)))
            var_value = random.randint(1000, 9999)
            dummy_vars.append(f"{var_name} = {var_value}")
        
        return '\n'.join(dummy_funcs) + '\n' + '\n'.join(dummy_vars) + '\n' + code
    
    def scramble_imports(self, code: str) -> str:
        """Scramble import statements"""
        imports = re.findall(r'^(import .+|from .+ import .+)$', code, re.MULTILINE)
        for imp in imports:
            if 'os' not in imp and 'sys' not in imp:  # Keep essential imports readable
                scrambled = base64.b64encode(imp.encode()).decode()
                replacement = f'exec(__import__("base64").b64decode("{scrambled}").decode())'
                code = code.replace(imp, replacement)
        return code
    
    def compress_and_encode(self, code: str) -> str:
        """Compress and encode the code"""
        # Compress first
        compressed = zlib.compress(code.encode(), level=9)
        # Base64 encode
        encoded = base64.b64encode(compressed).decode()
        return encoded
    
    def encrypt_code(self, code: str, password: str) -> tuple:
        """Encrypt the code with a password"""
        salt = os.urandom(self.salt_length)
        key = self.generate_key(password, salt)
        fernet = Fernet(key)
        encrypted = fernet.encrypt(code.encode())
        return base64.b64encode(salt + encrypted).decode(), salt.hex()
    
    def protect_code(self, original_code: str, user_id: int) -> str:
        """Apply all protection layers"""
        try:
            # Generate unique password for this user/file
            password = hashlib.sha256(f"{user_id}_{random.randint(10000, 99999)}".encode()).hexdigest()[:16]
            
            # Step 1: Add dummy code
            code = self.add_dummy_code(original_code)
            
            # Step 2: Obfuscate strings (commented out to avoid breaking syntax)
            # code = self.obfuscate_strings(code)
            
            # Step 3: Scramble imports
            code = self.scramble_imports(code)
            
            # Step 4: Compress and encode
            compressed = self.compress_and_encode(code)
            
            # Step 5: Encrypt
            encrypted_data, salt_hex = self.encrypt_code(compressed, password)
            
            # Create protected wrapper
            protected_code = f'''
# Protected Python Code - Generated by CodeProtector
# Attempting to reverse engineer this code violates terms of use
import base64, zlib, os, hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

def __decrypt_and_run():
    __salt = bytes.fromhex("{salt_hex}")
    __encrypted_data = "{encrypted_data}"
    __user_key = "{password}"
    
    def __generate_key(__password, __salt):
        __kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=__salt, iterations=100000)
        return base64.urlsafe_b64encode(__kdf.derive(__password.encode()))
    
    try:
        __key = __generate_key(__user_key, __salt)
        __fernet = Fernet(__key)
        __data = base64.b64decode(__encrypted_data)
        __decrypted = __fernet.decrypt(__data[32:])  # Skip salt
        __decompressed = zlib.decompress(base64.b64decode(__decrypted)).decode()
        exec(__decompressed, globals())
    except Exception as __e:
        print("Authentication failed or code corrupted")
        exit(1)

if __name__ == "__main__":
    __decrypt_and_run()
'''
            return protected_code
            
        except Exception as e:
            raise Exception(f"Protection failed: {str(e)}")

protector = CodeProtector()

@bot.message_handler(commands=['start'])
def start_command(message):
    welcome_text = """
üîê **Python Code Protector Bot**

Welcome! This bot helps protect your Python source code through multiple layers of obfuscation and encryption.

**Features:**
- Multi-layer code obfuscation
- Compression to minimize file size
- Encryption with unique keys
- Dummy code injection
- Import scrambling

**How to use:**
1. Send me your Python file (.py) or paste your code directly
2. I'll process and protect your code
3. Download the protected version

**Note:** This provides obfuscation, not absolute security. For critical applications, consider server-side execution or compiled languages.

üìÑ Send your Python file or code to get started!
"""
    bot.reply_to(message, welcome_text, parse_mode='Markdown')

@bot.message_handler(content_types=['document'])
def handle_file(message):
    try:
        # Check if it's a Python file
        if not message.document.file_name.endswith('.py'):
            bot.reply_to(message, "‚ùå Please send only Python (.py) files!")
            return
        
        # Check file size (limit to 10MB)
        if message.document.file_size > 10 * 1024 * 1024:
            bot.reply_to(message, "‚ùå File too large! Maximum size is 10MB.")
            return
        
        # Download file
        file_info = bot.get_file(message.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)
        
        # Process the code
        bot.reply_to(message, "üîÑ Processing your code... Please wait.")
        
        original_code = downloaded_file.decode('utf-8')
        
        # Protect the code
        protected_code = protector.protect_code(original_code, message.from_user.id)
        
        # Create protected file
        protected_filename = f"protected_{message.document.file_name}"
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.py') as temp_file:
            temp_file.write(protected_code)
            temp_file_path = temp_file.name
        
        # Send protected file back
        with open(temp_file_path, 'rb') as protected_file:
            bot.send_document(
                message.chat.id,
                protected_file,
                caption=f"üîê **Protected Code Generated!**\n\n"
                       f"Original size: {len(original_code)} bytes\n"
                       f"Protected size: {len(protected_code)} bytes\n"
                       f"Compression ratio: {len(protected_code)/len(original_code):.2f}x\n\n"
                       f"**Security Features Applied:**\n"
                       f"‚úÖ Encryption with unique key\n"
                       f"‚úÖ Code compression\n"
                       f"‚úÖ Dummy code injection\n"
                       f"‚úÖ Import obfuscation\n\n"
                       f"*Note: Install required dependencies: `pip install cryptography`*",
                parse_mode='Markdown'
            )
        
        # Clean up
        os.unlink(temp_file_path)
        
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error processing file: {str(e)}")

@bot.message_handler(content_types=['text'])
def handle_text_code(message):
    try:
        # Skip commands and short messages
        if message.text.startswith('/') or len(message.text) < 50:
            bot.reply_to(message, "üìÑ Please send your Python code (minimum 50 characters) or upload a .py file!")
            return
        
        # Check if it looks like Python code
        if not any(keyword in message.text.lower() for keyword in ['import', 'def ', 'class ', 'if ', 'for ', 'while ', 'print']):
            bot.reply_to(message, "ü§î This doesn't look like Python code. Please send valid Python code or a .py file!")
            return
        
        bot.reply_to(message, "üîÑ Processing your code... Please wait.")
        
        # Protect the code
        protected_code = protector.protect_code(message.text, message.from_user.id)
        
        # Create and send protected file
        protected_filename = f"protected_code_{message.from_user.id}.py"
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.py') as temp_file:
            temp_file.write(protected_code)
            temp_file_path = temp_file.name
        
        with open(temp_file_path, 'rb') as protected_file:
            bot.send_document(
                message.chat.id,
                protected_file,
                caption=f"üîê **Protected Code Generated!**\n\n"
                       f"Original size: {len(message.text)} bytes\n"
                       f"Protected size: {len(protected_code)} bytes\n"
                       f"Compression ratio: {len(protected_code)/len(message.text):.2f}x\n\n"
                       f"**Security Features Applied:**\n"
                       f"‚úÖ Encryption with unique key\n"
                       f"‚úÖ Code compression\n"
                       f"‚úÖ Dummy code injection\n"
                       f"‚úÖ Import obfuscation\n\n"
                       f"*Note: Install required dependencies: `pip install cryptography`*",
                parse_mode='Markdown'
            )
        
        # Clean up
        os.unlink(temp_file_path)
        
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error processing code: {str(e)}")

@bot.message_handler(commands=['help'])
def help_command(message):
    help_text = """
üîê **Python Code Protector Bot - Help**

**Commands:**
/start - Start the bot and see welcome message
/help - Show this help message

**Supported Input:**
- Python files (.py) up to 10MB
- Direct code text (minimum 50 characters)

**Protection Features:**
üîí **Encryption**: AES encryption with PBKDF2 key derivation
üóúÔ∏è **Compression**: Zlib compression to reduce size
üé≠ **Obfuscation**: Multiple layers of code scrambling
üîÄ **Dummy Code**: Random functions and variables injection
üì¶ **Import Scrambling**: Encoded import statements

**Dependencies for Protected Code:**
```bash
pip install cryptography
```

**Security Notes:**
- This provides obfuscation, not absolute protection
- Determined attackers may still reverse engineer
- Consider server-side execution for critical applications
- Use compiled languages for better protection

**File Size Impact:**
- Typical increase: 2-4x original size
- 20KB ‚Üí ~40-80KB (acceptable range)
- Compression helps minimize bloat

Need support? Contact the developer!
"""
    bot.reply_to(message, help_text, parse_mode='Markdown')

# Error handler
@bot.message_handler(func=lambda message: True)
def handle_unknown(message):
    bot.reply_to(message, "‚ùì Unknown command or invalid input. Use /help for assistance!")

if __name__ == "__main__":
    print("üöÄ Code Protector Bot Starting...")
    print("üîë Make sure to set your BOT_TOKEN environment variable!")
    
    # For Render deployment, use webhooks instead of polling
    if os.getenv('RENDER'):
        # Webhook setup for production
        from flask import Flask, request
        
        app = Flask(__name__)
        
        @app.route('/webhook', methods=['POST'])
        def webhook():
            json_string = request.get_data().decode('utf-8')
            update = telebot.types.Update.de_json(json_string)
            bot.process_new_updates([update])
            return "OK", 200
        
        @app.route('/')
        def index():
            return "Code Protector Bot is running!"
        
        # Set webhook
        webhook_url = f"https://{os.getenv('RENDER_EXTERNAL_HOSTNAME')}/webhook"
        bot.remove_webhook()
        bot.set_webhook(url=webhook_url)
        
        app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)))
    else:
        # Local development with polling
        print("üîÑ Using polling for local development...")
        bot.polling(none_stop=True)
